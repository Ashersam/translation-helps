{"version":3,"sources":["../node_modules/is-whitespace-character/index.js","../node_modules/xtend/immutable.js","../node_modules/repeat-string/index.js","../node_modules/trim/index.js","../node_modules/unist-util-visit/index.js","../node_modules/parse-entities/index.js","../node_modules/is-decimal/index.js","../node_modules/trim-trailing-lines/index.js","../node_modules/unherit/index.js","../node_modules/state-toggle/index.js","../node_modules/is-alphabetical/index.js","../node_modules/markdown-escapes/index.js","../node_modules/collapse-white-space/index.js","../node_modules/extend/index.js","../node_modules/bail/index.js","../node_modules/vfile-message/index.js","../node_modules/replace-ext/index.js","../node_modules/trough/index.js","../node_modules/x-is-string/index.js","../node_modules/is-plain-obj/index.js","../node_modules/vfile-location/index.js","../node_modules/is-hexadecimal/index.js","../node_modules/is-alphanumerical/index.js","../node_modules/unist-util-remove-position/index.js","../node_modules/unist-util-is/index.js","../node_modules/is-word-character/index.js","../node_modules/unist-util-stringify-position/index.js","../node_modules/trough/wrap.js","../node_modules/inherits/inherits_browser.js","../node_modules/parse-entities/decode-entity.browser.js","../node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js"],"names":["module","exports","character","re","test","fromCode","charAt","String","fromCharCode","target","i","arguments","length","source","key","hasOwnProperty","call","Object","prototype","cache","res","str","num","TypeError","max","substr","replace","left","right","visit","visitParents","__webpack_require__","CONTINUE","SKIP","EXIT","tree","visitor","reverse","node","parents","parent","index","children","indexOf","legacy","invalid","decimal","hexadecimal","alphanumerical","decodeEntity","value","options","option","settings","defaults","undefined","position","indent","start","entityCharacters","namedEntity","terminated","characters","reference","following","warning","reason","output","entity","begin","type","prev","next","diff","end","additional","nonTerminated","handleText","text","handleReference","handleWarning","textContext","referenceContext","warningContext","pos","lines","column","line","queue","result","now","code","offset","MESSAGES","noop","at","flush","NAMED","HEXADECIMAL","DECIMAL","TESTS","own","NAMED_UNKNOWN","NAMED_NOT_TERMINATED","NAMED_EMPTY","attribute","NUMERIC_NOT_TERMINATED","parseInt","BASE","NUMERIC_PROHIBITED","NUMERIC_DISALLOWED","disallowed","NUMERIC_EMPTY","push","slice","join","parse","Function","charCodeAt","val","xtend","inherits","Super","Of","From","concat","parameters","apply","this","state","ctx","context","current","escapes","gfm","commonmark","default","hasOwn","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","name","enumerable","configurable","newValue","writable","getProperty","extend","src","copy","copyIsArray","clone","deep","err","stringify","VMessagePrototype","VMessage","Error","proto","origin","parts","range","location","parseOrigin","stack","message","ruleId","file","fatal","path","npath","ext","nFileName","basename","extname","dirname","wrap","trough","fns","middleware","run","input","done","fn","params","values","use","x","getPrototypeOf","offsetToPositionFactory","indices","positionToOffsetFactory","isNaN","contents","toPosition","toOffset","alphabetical","hard","soft","force","convert","Boolean","typeFactory","ok","tests","checks","results","convertAll","is","hasParent","hasIndex","check","Infinity","point","callback","invoked","then","create","ctor","superCtor","super_","TempCtor","el","char","document","createElement","innerHTML","textContent","one","child","step","all"],"mappings":"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","file":"static/js/1.f7c552ee.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = whitespace;\nvar fromCode = String.fromCharCode;\nvar re = /\\s/;\n/* Check if the given character code, or the character\n * code at the first character, is a whitespace character. */\n\nfunction whitespace(character) {\n  return re.test(typeof character === 'number' ? fromCode(character) : character.charAt(0));\n}","module.exports = extend;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n  var target = {};\n\n  for (var i = 0; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n}","/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  } // cover common, quick use cases\n\n\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n  var max = str.length * num;\n\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}","exports = module.exports = trim;\n\nfunction trim(str) {\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function (str) {\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function (str) {\n  return str.replace(/\\s*$/, '');\n};","'use strict';\n\nmodule.exports = visit;\n\nvar visitParents = require('unist-util-visit-parents');\n\nvar CONTINUE = visitParents.CONTINUE;\nvar SKIP = visitParents.SKIP;\nvar EXIT = visitParents.EXIT;\nvisit.CONTINUE = CONTINUE;\nvisit.SKIP = SKIP;\nvisit.EXIT = EXIT;\n\nfunction visit(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n\n  visitParents(tree, test, overload, reverse);\n\n  function overload(node, parents) {\n    var parent = parents[parents.length - 1];\n    var index = parent ? parent.children.indexOf(node) : null;\n    return visitor(node, index, parent);\n  }\n}","'use strict';\n\nvar legacy = require('character-entities-legacy');\n\nvar invalid = require('character-reference-invalid');\n\nvar decimal = require('is-decimal');\n\nvar hexadecimal = require('is-hexadecimal');\n\nvar alphanumerical = require('is-alphanumerical');\n\nvar decodeEntity = require('./decode-entity');\n\nmodule.exports = parseEntities;\nvar own = {}.hasOwnProperty;\nvar fromCharCode = String.fromCharCode;\nvar noop = Function.prototype;\n/* Default settings. */\n\nvar defaults = {\n  warning: null,\n  reference: null,\n  text: null,\n  warningContext: null,\n  referenceContext: null,\n  textContext: null,\n  position: {},\n  additional: null,\n  attribute: false,\n  nonTerminated: true\n  /* Reference types. */\n\n};\nvar NAMED = 'named';\nvar HEXADECIMAL = 'hexadecimal';\nvar DECIMAL = 'decimal';\n/* Map of bases. */\n\nvar BASE = {};\nBASE[HEXADECIMAL] = 16;\nBASE[DECIMAL] = 10;\n/* Map of types to tests. Each type of character reference\n * accepts different characters. This test is used to\n * detect whether a reference has ended (as the semicolon\n * is not strictly needed). */\n\nvar TESTS = {};\nTESTS[NAMED] = alphanumerical;\nTESTS[DECIMAL] = decimal;\nTESTS[HEXADECIMAL] = hexadecimal;\n/* Warning messages. */\n\nvar NAMED_NOT_TERMINATED = 1;\nvar NUMERIC_NOT_TERMINATED = 2;\nvar NAMED_EMPTY = 3;\nvar NUMERIC_EMPTY = 4;\nvar NAMED_UNKNOWN = 5;\nvar NUMERIC_DISALLOWED = 6;\nvar NUMERIC_PROHIBITED = 7;\nvar MESSAGES = {};\nMESSAGES[NAMED_NOT_TERMINATED] = 'Named character references must be terminated by a semicolon';\nMESSAGES[NUMERIC_NOT_TERMINATED] = 'Numeric character references must be terminated by a semicolon';\nMESSAGES[NAMED_EMPTY] = 'Named character references cannot be empty';\nMESSAGES[NUMERIC_EMPTY] = 'Numeric character references cannot be empty';\nMESSAGES[NAMED_UNKNOWN] = 'Named character references must be known';\nMESSAGES[NUMERIC_DISALLOWED] = 'Numeric character references cannot be disallowed';\nMESSAGES[NUMERIC_PROHIBITED] = 'Numeric character references cannot be outside the permissible Unicode range';\n/* Wrap to ensure clean parameters are given to `parse`. */\n\nfunction parseEntities(value, options) {\n  var settings = {};\n  var option;\n  var key;\n\n  if (!options) {\n    options = {};\n  }\n\n  for (key in defaults) {\n    option = options[key];\n    settings[key] = option === null || option === undefined ? defaults[key] : option;\n  }\n\n  if (settings.position.indent || settings.position.start) {\n    settings.indent = settings.position.indent || [];\n    settings.position = settings.position.start;\n  }\n\n  return parse(value, settings);\n}\n/* Parse entities. */\n\n\nfunction parse(value, settings) {\n  var additional = settings.additional;\n  var nonTerminated = settings.nonTerminated;\n  var handleText = settings.text;\n  var handleReference = settings.reference;\n  var handleWarning = settings.warning;\n  var textContext = settings.textContext;\n  var referenceContext = settings.referenceContext;\n  var warningContext = settings.warningContext;\n  var pos = settings.position;\n  var indent = settings.indent || [];\n  var length = value.length;\n  var index = 0;\n  var lines = -1;\n  var column = pos.column || 1;\n  var line = pos.line || 1;\n  var queue = '';\n  var result = [];\n  var entityCharacters;\n  var namedEntity;\n  var terminated;\n  var characters;\n  var character;\n  var reference;\n  var following;\n  var warning;\n  var reason;\n  var output;\n  var entity;\n  var begin;\n  var start;\n  var type;\n  var test;\n  var prev;\n  var next;\n  var diff;\n  var end;\n  /* Cache the current point. */\n\n  prev = now();\n  /* Wrap `handleWarning`. */\n\n  warning = handleWarning ? parseError : noop;\n  /* Ensure the algorithm walks over the first character\n   * and the end (inclusive). */\n\n  index--;\n  length++;\n\n  while (++index < length) {\n    /* If the previous character was a newline. */\n    if (character === '\\n') {\n      column = indent[lines] || 1;\n    }\n\n    character = at(index);\n    /* Handle anything other than an ampersand,\n     * including newlines and EOF. */\n\n    if (character !== '&') {\n      if (character === '\\n') {\n        line++;\n        lines++;\n        column = 0;\n      }\n\n      if (character) {\n        queue += character;\n        column++;\n      } else {\n        flush();\n      }\n    } else {\n      following = at(index + 1);\n      /* The behaviour depends on the identity of the next\n       * character. */\n\n      if (following === '\\t'\n      /* Tab */\n      || following === '\\n'\n      /* Newline */\n      || following === '\\f'\n      /* Form feed */\n      || following === ' '\n      /* Space */\n      || following === '<'\n      /* Less-than */\n      || following === '&'\n      /* Ampersand */\n      || following === '' || additional && following === additional) {\n        /* Not a character reference. No characters\n         * are consumed, and nothing is returned.\n         * This is not an error, either. */\n        queue += character;\n        column++;\n        continue;\n      }\n\n      start = index + 1;\n      begin = start;\n      end = start;\n      /* Numerical entity. */\n\n      if (following !== '#') {\n        type = NAMED;\n      } else {\n        end = ++begin;\n        /* The behaviour further depends on the\n         * character after the U+0023 NUMBER SIGN. */\n\n        following = at(end);\n\n        if (following === 'x' || following === 'X') {\n          /* ASCII hex digits. */\n          type = HEXADECIMAL;\n          end = ++begin;\n        } else {\n          /* ASCII digits. */\n          type = DECIMAL;\n        }\n      }\n\n      entityCharacters = '';\n      entity = '';\n      characters = '';\n      test = TESTS[type];\n      end--;\n\n      while (++end < length) {\n        following = at(end);\n\n        if (!test(following)) {\n          break;\n        }\n\n        characters += following;\n        /* Check if we can match a legacy named\n         * reference.  If so, we cache that as the\n         * last viable named reference.  This\n         * ensures we do not need to walk backwards\n         * later. */\n\n        if (type === NAMED && own.call(legacy, characters)) {\n          entityCharacters = characters;\n          entity = legacy[characters];\n        }\n      }\n\n      terminated = at(end) === ';';\n\n      if (terminated) {\n        end++;\n        namedEntity = type === NAMED ? decodeEntity(characters) : false;\n\n        if (namedEntity) {\n          entityCharacters = characters;\n          entity = namedEntity;\n        }\n      }\n\n      diff = 1 + end - start;\n\n      if (!terminated && !nonTerminated) {\n        /* Empty. */\n      } else if (!characters) {\n        /* An empty (possible) entity is valid, unless\n         * its numeric (thus an ampersand followed by\n         * an octothorp). */\n        if (type !== NAMED) {\n          warning(NUMERIC_EMPTY, diff);\n        }\n      } else if (type === NAMED) {\n        /* An ampersand followed by anything\n         * unknown, and not terminated, is invalid. */\n        if (terminated && !entity) {\n          warning(NAMED_UNKNOWN, 1);\n        } else {\n          /* If theres something after an entity\n           * name which is not known, cap the\n           * reference. */\n          if (entityCharacters !== characters) {\n            end = begin + entityCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          }\n          /* If the reference is not terminated,\n           * warn. */\n\n\n          if (!terminated) {\n            reason = entityCharacters ? NAMED_NOT_TERMINATED : NAMED_EMPTY;\n\n            if (!settings.attribute) {\n              warning(reason, diff);\n            } else {\n              following = at(end);\n\n              if (following === '=') {\n                warning(reason, diff);\n                entity = null;\n              } else if (alphanumerical(following)) {\n                entity = null;\n              } else {\n                warning(reason, diff);\n              }\n            }\n          }\n        }\n\n        reference = entity;\n      } else {\n        if (!terminated) {\n          /* All non-terminated numeric entities are\n           * not rendered, and trigger a warning. */\n          warning(NUMERIC_NOT_TERMINATED, diff);\n        }\n        /* When terminated and number, parse as\n         * either hexadecimal or decimal. */\n\n\n        reference = parseInt(characters, BASE[type]);\n        /* Trigger a warning when the parsed number\n         * is prohibited, and replace with\n         * replacement character. */\n\n        if (prohibited(reference)) {\n          warning(NUMERIC_PROHIBITED, diff);\n          reference = \"\\uFFFD\";\n        } else if (reference in invalid) {\n          /* Trigger a warning when the parsed number\n           * is disallowed, and replace by an\n           * alternative. */\n          warning(NUMERIC_DISALLOWED, diff);\n          reference = invalid[reference];\n        } else {\n          /* Parse the number. */\n          output = '';\n          /* Trigger a warning when the parsed\n           * number should not be used. */\n\n          if (disallowed(reference)) {\n            warning(NUMERIC_DISALLOWED, diff);\n          }\n          /* Stringify the number. */\n\n\n          if (reference > 0xffff) {\n            reference -= 0x10000;\n            output += fromCharCode(reference >>> (10 & 0x3ff) | 0xd800);\n            reference = 0xdc00 | reference & 0x3ff;\n          }\n\n          reference = output + fromCharCode(reference);\n        }\n      }\n      /* If we could not find a reference, queue the\n       * checked characters (as normal characters),\n       * and move the pointer to their end. This is\n       * possible because we can be certain neither\n       * newlines nor ampersands are included. */\n\n\n      if (!reference) {\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      } else {\n        /* Found it! First eat the queued\n         * characters as normal text, then eat\n         * an entity. */\n        flush();\n        prev = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        next = now();\n        next.offset++;\n\n        if (handleReference) {\n          handleReference.call(referenceContext, reference, {\n            start: prev,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n\n        prev = next;\n      }\n    }\n  }\n  /* Return the reduced nodes, and any possible warnings. */\n\n\n  return result.join('');\n  /* Get current position. */\n\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + (pos.offset || 0)\n    };\n  }\n  /* “Throw” a parse-error: a warning. */\n\n\n  function parseError(code, offset) {\n    var position = now();\n    position.column += offset;\n    position.offset += offset;\n    handleWarning.call(warningContext, MESSAGES[code], position, code);\n  }\n  /* Get character at position. */\n\n\n  function at(position) {\n    return value.charAt(position);\n  }\n  /* Flush `queue` (normal text). Macro invoked before\n   * each entity and at the end of `value`.\n   * Does nothing when `queue` is empty. */\n\n\n  function flush() {\n    if (queue) {\n      result.push(queue);\n\n      if (handleText) {\n        handleText.call(textContext, queue, {\n          start: prev,\n          end: now()\n        });\n      }\n\n      queue = '';\n    }\n  }\n}\n/* Check if `character` is outside the permissible unicode range. */\n\n\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/* Check if `character` is disallowed. */\n\n\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}","'use strict';\n\nmodule.exports = decimal;\n/* Check if the given character code, or the character\n * code at the first character, is decimal. */\n\nfunction decimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character;\n  return code >= 48 && code <= 57;\n  /* 0-9 */\n}","'use strict';\n\nmodule.exports = trimTrailingLines;\nvar line = '\\n';\n/* Remove final newline characters from `value`. */\n\nfunction trimTrailingLines(value) {\n  var val = String(value);\n  var index = val.length;\n\n  while (val.charAt(--index) === line) {\n    /* Empty */\n  }\n\n  return val.slice(0, index + 1);\n}","'use strict';\n\nvar xtend = require('xtend');\n\nvar inherits = require('inherits');\n\nmodule.exports = unherit;\n/* Create a custom constructor which can be modified\n * without affecting the original class. */\n\nfunction unherit(Super) {\n  var result;\n  var key;\n  var value;\n  inherits(Of, Super);\n  inherits(From, Of);\n  /* Clone values. */\n\n  result = Of.prototype;\n\n  for (key in result) {\n    value = result[key];\n\n    if (value && typeof value === 'object') {\n      result[key] = 'concat' in value ? value.concat() : xtend(value);\n    }\n  }\n\n  return Of;\n  /* Constructor accepting a single argument,\n   * which itself is an `arguments` object. */\n\n  function From(parameters) {\n    return Super.apply(this, parameters);\n  }\n  /* Constructor accepting variadic arguments. */\n\n\n  function Of() {\n    if (!(this instanceof Of)) {\n      return new From(arguments);\n    }\n\n    return Super.apply(this, arguments);\n  }\n}","'use strict';\n\nmodule.exports = factory;\n/* Construct a state `toggler`: a function which inverses\n * `property` in context based on its current value.\n * The by `toggler` returned function restores that value. */\n\nfunction factory(key, state, ctx) {\n  return enter;\n\n  function enter() {\n    var context = ctx || this;\n    var current = context[key];\n    context[key] = !state;\n    return exit;\n\n    function exit() {\n      context[key] = current;\n    }\n  }\n}","'use strict';\n\nmodule.exports = alphabetical;\n/* Check if the given character code, or the character\n * code at the first character, is alphabetical. */\n\nfunction alphabetical(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character;\n  return code >= 97 && code <= 122 ||\n  /* a-z */\n  code >= 65 && code <= 90\n  /* A-Z */\n  ;\n}","'use strict';\n\nmodule.exports = escapes;\nvar defaults = ['\\\\', '`', '*', '{', '}', '[', ']', '(', ')', '#', '+', '-', '.', '!', '_', '>'];\nvar gfm = defaults.concat(['~', '|']);\nvar commonmark = gfm.concat(['\\n', '\"', '$', '%', '&', \"'\", ',', '/', ':', ';', '<', '=', '?', '@', '^']);\nescapes.default = defaults;\nescapes.gfm = gfm;\nescapes.commonmark = commonmark;\n/* Get markdown escapes. */\n\nfunction escapes(options) {\n  var settings = options || {};\n\n  if (settings.commonmark) {\n    return commonmark;\n  }\n\n  return settings.gfm ? gfm : defaults;\n}","'use strict';\n\nmodule.exports = collapse;\n/* collapse(' \\t\\nbar \\nbaz\\t'); // ' bar baz ' */\n\nfunction collapse(value) {\n  return String(value).replace(/\\s+/g, ' ');\n}","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n  if (typeof Array.isArray === 'function') {\n    return Array.isArray(arr);\n  }\n\n  return toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n  if (!obj || toStr.call(obj) !== '[object Object]') {\n    return false;\n  }\n\n  var hasOwnConstructor = hasOwn.call(obj, 'constructor');\n  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'); // Not own constructor property must be Object\n\n  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n    return false;\n  } // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n\n\n  var key;\n\n  for (key in obj) {\n    /**/\n  }\n\n  return typeof key === 'undefined' || hasOwn.call(obj, key);\n}; // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n\n\nvar setProperty = function setProperty(target, options) {\n  if (defineProperty && options.name === '__proto__') {\n    defineProperty(target, options.name, {\n      enumerable: true,\n      configurable: true,\n      value: options.newValue,\n      writable: true\n    });\n  } else {\n    target[options.name] = options.newValue;\n  }\n}; // Return undefined instead of __proto__ if '__proto__' is not an own property\n\n\nvar getProperty = function getProperty(obj, name) {\n  if (name === '__proto__') {\n    if (!hasOwn.call(obj, name)) {\n      return void 0;\n    } else if (gOPD) {\n      // In early versions of node, obj['__proto__'] is buggy when obj has\n      // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n      return gOPD(obj, name).value;\n    }\n  }\n\n  return obj[name];\n};\n\nmodule.exports = function extend() {\n  var options, name, src, copy, copyIsArray, clone;\n  var target = arguments[0];\n  var i = 1;\n  var length = arguments.length;\n  var deep = false; // Handle a deep copy situation\n\n  if (typeof target === 'boolean') {\n    deep = target;\n    target = arguments[1] || {}; // skip the boolean and the target\n\n    i = 2;\n  }\n\n  if (target == null || typeof target !== 'object' && typeof target !== 'function') {\n    target = {};\n  }\n\n  for (; i < length; ++i) {\n    options = arguments[i]; // Only deal with non-null/undefined values\n\n    if (options != null) {\n      // Extend the base object\n      for (name in options) {\n        src = getProperty(target, name);\n        copy = getProperty(options, name); // Prevent never-ending loop\n\n        if (target !== copy) {\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n            } else {\n              clone = src && isPlainObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            setProperty(target, {\n              name: name,\n              newValue: extend(deep, clone, copy)\n            }); // Don't bring in undefined values\n          } else if (typeof copy !== 'undefined') {\n            setProperty(target, {\n              name: name,\n              newValue: copy\n            });\n          }\n        }\n      }\n    }\n  } // Return the modified object\n\n\n  return target;\n};","'use strict';\n\nmodule.exports = bail;\n\nfunction bail(err) {\n  if (err) {\n    throw err;\n  }\n}","'use strict';\n\nvar stringify = require('unist-util-stringify-position');\n\nmodule.exports = VMessage; // Inherit from `Error#`.\n\nfunction VMessagePrototype() {}\n\nVMessagePrototype.prototype = Error.prototype;\nVMessage.prototype = new VMessagePrototype(); // Message properties.\n\nvar proto = VMessage.prototype;\nproto.file = '';\nproto.name = '';\nproto.reason = '';\nproto.message = '';\nproto.stack = '';\nproto.fatal = null;\nproto.column = null;\nproto.line = null; // Construct a new VMessage.\n//\n// Note: We cannot invoke `Error` on the created context, as that adds readonly\n// `line` and `column` attributes on Safari 9, thus throwing and failing the\n// data.\n\nfunction VMessage(reason, position, origin) {\n  var parts;\n  var range;\n  var location;\n\n  if (typeof position === 'string') {\n    origin = position;\n    position = null;\n  }\n\n  parts = parseOrigin(origin);\n  range = stringify(position) || '1:1';\n  location = {\n    start: {\n      line: null,\n      column: null\n    },\n    end: {\n      line: null,\n      column: null\n    } // Node.\n\n  };\n\n  if (position && position.position) {\n    position = position.position;\n  }\n\n  if (position) {\n    // Position.\n    if (position.start) {\n      location = position;\n      position = position.start;\n    } else {\n      // Point.\n      location.start = position;\n    }\n  }\n\n  if (reason.stack) {\n    this.stack = reason.stack;\n    reason = reason.message;\n  }\n\n  this.message = reason;\n  this.name = range;\n  this.reason = reason;\n  this.line = position ? position.line : null;\n  this.column = position ? position.column : null;\n  this.location = location;\n  this.source = parts[0];\n  this.ruleId = parts[1];\n}\n\nfunction parseOrigin(origin) {\n  var result = [null, null];\n  var index;\n\n  if (typeof origin === 'string') {\n    index = origin.indexOf(':');\n\n    if (index === -1) {\n      result[1] = origin;\n    } else {\n      result[0] = origin.slice(0, index);\n      result[1] = origin.slice(index + 1);\n    }\n  }\n\n  return result;\n}","'use strict';\n\nvar path = require('path');\n\nfunction replaceExt(npath, ext) {\n  if (typeof npath !== 'string') {\n    return npath;\n  }\n\n  if (npath.length === 0) {\n    return npath;\n  }\n\n  var nFileName = path.basename(npath, path.extname(npath)) + ext;\n  return path.join(path.dirname(npath), nFileName);\n}\n\nmodule.exports = replaceExt;","'use strict';\n\nvar wrap = require('./wrap.js');\n\nmodule.exports = trough;\ntrough.wrap = wrap;\nvar slice = [].slice;\n/* Create new middleware. */\n\nfunction trough() {\n  var fns = [];\n  var middleware = {};\n  middleware.run = run;\n  middleware.use = use;\n  return middleware;\n  /* Run `fns`.  Last argument must be\n   * a completion handler. */\n\n  function run() {\n    var index = -1;\n    var input = slice.call(arguments, 0, -1);\n    var done = arguments[arguments.length - 1];\n\n    if (typeof done !== 'function') {\n      throw new Error('Expected function as last argument, not ' + done);\n    }\n\n    next.apply(null, [null].concat(input));\n    /* Run the next `fn`, if any. */\n\n    function next(err) {\n      var fn = fns[++index];\n      var params = slice.call(arguments, 0);\n      var values = params.slice(1);\n      var length = input.length;\n      var pos = -1;\n\n      if (err) {\n        done(err);\n        return;\n      }\n      /* Copy non-nully input into values. */\n\n\n      while (++pos < length) {\n        if (values[pos] === null || values[pos] === undefined) {\n          values[pos] = input[pos];\n        }\n      }\n\n      input = values;\n      /* Next or done. */\n\n      if (fn) {\n        wrap(fn, next).apply(null, input);\n      } else {\n        done.apply(null, [null].concat(input));\n      }\n    }\n  }\n  /* Add `fn` to the list. */\n\n\n  function use(fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected `fn` to be a function, not ' + fn);\n    }\n\n    fns.push(fn);\n    return middleware;\n  }\n}","var toString = Object.prototype.toString;\nmodule.exports = isString;\n\nfunction isString(obj) {\n  return toString.call(obj) === \"[object String]\";\n}","'use strict';\n\nvar toString = Object.prototype.toString;\n\nmodule.exports = function (x) {\n  var prototype;\n  return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));\n};","'use strict';\n\nmodule.exports = factory;\n\nfunction factory(file) {\n  var contents = indices(String(file));\n  return {\n    toPosition: offsetToPositionFactory(contents),\n    toOffset: positionToOffsetFactory(contents)\n  };\n} // Factory to get the line and column-based `position` for `offset` in the bound\n// indices.\n\n\nfunction offsetToPositionFactory(indices) {\n  return offsetToPosition; // Get the line and column-based `position` for `offset` in the bound indices.\n\n  function offsetToPosition(offset) {\n    var index = -1;\n    var length = indices.length;\n\n    if (offset < 0) {\n      return {};\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        };\n      }\n    }\n\n    return {};\n  }\n} // Factory to get the `offset` for a line and column-based `position` in the\n// bound indices.\n\n\nfunction positionToOffsetFactory(indices) {\n  return positionToOffset; // Get the `offset` for a line and column-based `position` in the bound\n  // indices.\n\n  function positionToOffset(position) {\n    var line = position && position.line;\n    var column = position && position.column;\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0;\n    }\n\n    return -1;\n  }\n} // Get indices of line-breaks in `value`.\n\n\nfunction indices(value) {\n  var result = [];\n  var index = value.indexOf('\\n');\n\n  while (index !== -1) {\n    result.push(index + 1);\n    index = value.indexOf('\\n', index + 1);\n  }\n\n  result.push(value.length + 1);\n  return result;\n}","'use strict';\n\nmodule.exports = hexadecimal;\n/* Check if the given character code, or the character\n * code at the first character, is hexadecimal. */\n\nfunction hexadecimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character;\n  return code >= 97\n  /* a */\n  && code <= 102 ||\n  /* z */\n  code >= 65\n  /* A */\n  && code <= 70\n  /* Z */\n  || code >= 48\n  /* A */\n  && code <= 57\n  /* Z */\n  ;\n}","'use strict';\n\nvar alphabetical = require('is-alphabetical');\n\nvar decimal = require('is-decimal');\n\nmodule.exports = alphanumerical;\n/* Check if the given character code, or the character\n * code at the first character, is alphanumerical. */\n\nfunction alphanumerical(character) {\n  return alphabetical(character) || decimal(character);\n}","'use strict';\n\nvar visit = require('unist-util-visit');\n\nmodule.exports = removePosition;\n/* Remove `position`s from `tree`. */\n\nfunction removePosition(node, force) {\n  visit(node, force ? hard : soft);\n  return node;\n}\n\nfunction hard(node) {\n  delete node.position;\n}\n\nfunction soft(node) {\n  node.position = undefined;\n}","'use strict';\n/* eslint-disable max-params */\n\n/* Expose. */\n\nmodule.exports = is;\n/* Assert if `test` passes for `node`.\n * When a `parent` node is known the `index` of node */\n\nfunction is(test, node, index, parent, context) {\n  var hasParent = parent !== null && parent !== undefined;\n  var hasIndex = index !== null && index !== undefined;\n  var check = convert(test);\n\n  if (hasIndex && (typeof index !== 'number' || index < 0 || index === Infinity)) {\n    throw new Error('Expected positive finite index or child node');\n  }\n\n  if (hasParent && (!is(null, parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false;\n  }\n\n  if (hasParent !== hasIndex) {\n    throw new Error('Expected both parent and index');\n  }\n\n  return Boolean(check.call(context, node, index, parent));\n}\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (test === null || test === undefined) {\n    return ok;\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test);\n  }\n\n  if (typeof test === 'function') {\n    return test;\n  }\n\n  throw new Error('Expected function, string, or object as test');\n}\n\nfunction convertAll(tests) {\n  var results = [];\n  var length = tests.length;\n  var index = -1;\n\n  while (++index < length) {\n    results[index] = convert(tests[index]);\n  }\n\n  return results;\n}\n/* Utility assert each property in `test` is represented\n * in `node`, and each values are strictly equal. */\n\n\nfunction matchesFactory(test) {\n  return matches;\n\n  function matches(node) {\n    var key;\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests);\n  var length = checks.length;\n  return matches;\n\n  function matches() {\n    var index = -1;\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n/* Utility to convert a string into a function which checks\n * a given node’s type for said string. */\n\n\nfunction typeFactory(test) {\n  return type;\n\n  function type(node) {\n    return Boolean(node && node.type === test);\n  }\n}\n/* Utility to return true. */\n\n\nfunction ok() {\n  return true;\n}","'use strict';\n\nmodule.exports = wordCharacter;\nvar fromCode = String.fromCharCode;\nvar re = /\\w/;\n/* Check if the given character code, or the character\n * code at the first character, is a word character. */\n\nfunction wordCharacter(character) {\n  return re.test(typeof character === 'number' ? fromCode(character) : character.charAt(0));\n}","'use strict';\n\nvar own = {}.hasOwnProperty;\nmodule.exports = stringify;\n\nfunction stringify(value) {\n  /* Nothing. */\n  if (!value || typeof value !== 'object') {\n    return null;\n  }\n  /* Node. */\n\n\n  if (own.call(value, 'position') || own.call(value, 'type')) {\n    return position(value.position);\n  }\n  /* Position. */\n\n\n  if (own.call(value, 'start') || own.call(value, 'end')) {\n    return position(value);\n  }\n  /* Point. */\n\n\n  if (own.call(value, 'line') || own.call(value, 'column')) {\n    return point(value);\n  }\n  /* ? */\n\n\n  return null;\n}\n\nfunction point(point) {\n  if (!point || typeof point !== 'object') {\n    point = {};\n  }\n\n  return index(point.line) + ':' + index(point.column);\n}\n\nfunction position(pos) {\n  if (!pos || typeof pos !== 'object') {\n    pos = {};\n  }\n\n  return point(pos.start) + '-' + point(pos.end);\n}\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1;\n}","'use strict';\n\nvar slice = [].slice;\nmodule.exports = wrap;\n/* Wrap `fn`.  Can be sync or async; return a promise,\n * receive a completion handler, return new values and\n * errors. */\n\nfunction wrap(fn, callback) {\n  var invoked;\n  return wrapped;\n\n  function wrapped() {\n    var params = slice.call(arguments, 0);\n    var callback = fn.length > params.length;\n    var result;\n\n    if (callback) {\n      params.push(done);\n    }\n\n    try {\n      result = fn.apply(null, params);\n    } catch (err) {\n      /* Well, this is quite the pickle.  `fn` received\n       * a callback and invoked it (thus continuing the\n       * pipeline), but later also threw an error.\n       * We’re not about to restart the pipeline again,\n       * so the only thing left to do is to throw the\n       * thing instea. */\n      if (callback && invoked) {\n        throw err;\n      }\n\n      return done(err);\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  }\n  /* Invoke `next`, only once. */\n\n\n  function done() {\n    if (!invoked) {\n      invoked = true;\n      callback.apply(null, arguments);\n    }\n  }\n  /* Invoke `done` with one value.\n   * Tracks if an error is passed, too. */\n\n\n  function then(value) {\n    done(null, value);\n  }\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n\n    var TempCtor = function TempCtor() {};\n\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}","'use strict';\n/* eslint-env browser */\n\nvar el;\nmodule.exports = decodeEntity;\n\nfunction decodeEntity(characters) {\n  var entity = '&' + characters + ';';\n  var char;\n  el = el || document.createElement('i');\n  el.innerHTML = entity;\n  char = el.textContent; // Some entities do not require the closing semicolon (&not - for instance),\n  // which leads to situations where parsing the assumed entity of &notit; will\n  // result in the string `¬it;`.  When we encounter a trailing semicolon after\n  // parsing and the entity to decode was not a semicolon (&semi;), we can\n  // assume that the matching was incomplete\n\n  if (char.slice(-1) === ';' && characters !== 'semi') {\n    return false;\n  } // If the decoded string is equal to the input, the entity was not valid\n\n\n  return char === entity ? false : char;\n}","'use strict';\n\nmodule.exports = visitParents;\n\nvar is = require('unist-util-is');\n\nvar CONTINUE = true;\nvar SKIP = 'skip';\nvar EXIT = false;\nvisitParents.CONTINUE = CONTINUE;\nvisitParents.SKIP = SKIP;\nvisitParents.EXIT = EXIT;\n\nfunction visitParents(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n\n  one(tree, null, []); // Visit a single node.\n\n  function one(node, index, parents) {\n    var result;\n\n    if (!test || is(test, node, index, parents[parents.length - 1] || null)) {\n      result = visitor(node, parents);\n\n      if (result === EXIT) {\n        return result;\n      }\n    }\n\n    if (node.children && result !== SKIP) {\n      return all(node.children, parents.concat(node)) === EXIT ? EXIT : result;\n    }\n\n    return result;\n  } // Visit children in `parent`.\n\n\n  function all(children, parents) {\n    var min = -1;\n    var step = reverse ? -1 : 1;\n    var index = (reverse ? children.length : min) + step;\n    var child;\n    var result;\n\n    while (index > min && index < children.length) {\n      child = children[index];\n      result = child && one(child, index, parents);\n\n      if (result === EXIT) {\n        return result;\n      }\n\n      index = typeof result === 'number' ? result : index + step;\n    }\n  }\n}"],"sourceRoot":""}